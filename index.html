<script>
  const nowTimeLbl = document.getElementById("now_time");
  const minutesLbl = document.getElementById("minutes");
  const secondsLbl = document.getElementById("seconds");
  const startBtn = document.getElementById("startButton");
  const resetBtn = document.getElementById("reset");
  const endBtn = document.getElementById("end");
  const wrapBtn = document.getElementById("wrap");
  const wrapListDom = document.getElementById("wrapList");
  const titleArea = document.getElementById("title_area");

  let timer = null;
  let startTime = 0;
  let passTime = 0;
  let wrapList = [];
  let lastStartDate = null;
  let isManuallyBlocked = false;
  let pauseStartTime = 0;
  let pausedDuration = 0;
  let lastWrapStart = null;
  let wasBlocked = false;

  const params = new URLSearchParams(window.location.search);
  let customTitle = params.get("title");
  if (customTitle) {
    titleArea.textContent = customTitle;
    document.title = customTitle;
  }

  const zeroPad = (num, digits) => String(num).padStart(digits, "0");

  const blockedTimeRanges = [
    ["10:15", "10:25"], ["12:15", "13:00"], ["15:00", "15:10"], ["09:15", "09:17"],
    ["17:10", "17:20"], ["19:20", "19:30"], ["22:15", "22:25"],
    ["00:15", "01:00"], ["03:00", "03:10"], ["05:10", "05:20"], ["07:20", "07:30"]
  ];

  const isBlockedTime = () => {
    const now = new Date();
    const hhmm = `${zeroPad(now.getHours(),2)}:${zeroPad(now.getMinutes(),2)}`;
    return blockedTimeRanges.some(([start, end]) => {
      if (start > end) return hhmm >= start || hhmm < end;
      return hhmm >= start && hhmm < end;
    }) || isManuallyBlocked;
  };

  const getPassTime = () => {
    const now = new Date().getTime();
    if (pauseStartTime && isManuallyBlocked) {
      return Math.floor((pauseStartTime - startTime - pausedDuration) / 1000);
    }
    return Math.floor((now - startTime - pausedDuration) / 1000);
  };

  const countUp = () => {
    passTime = getPassTime();
    minutesLbl.innerText = zeroPad(Math.floor(passTime / 60), 3);
    secondsLbl.innerText = zeroPad(passTime % 60, 2);
  };

  const updateNowTime = () => {
    const now = new Date();
    nowTimeLbl.innerText = `${zeroPad(now.getHours(),2)}:${zeroPad(now.getMinutes(),2)}:${zeroPad(now.getSeconds(),2)}`;

    const blocked = isBlockedTime();
    if (blocked && !wasBlocked && timer) {
      pauseStartTime = new Date().getTime();
      clearInterval(timer);
      timer = null;
    }
    if (!blocked && wasBlocked && startTime !== 0 && !timer) {
      pausedDuration += new Date().getTime() - pauseStartTime;
      timer = setInterval(countUp, 100);
    }
    wasBlocked = blocked;

    startBtn.disabled = !(startTime === 0);
  };
  setInterval(updateNowTime, 1000);
  updateNowTime();

  const setupTimer = () => {
    passTime = 0;
    pausedDuration = 0;
    pauseStartTime = 0;
    isManuallyBlocked = false;
    minutesLbl.innerText = zeroPad(0, 3);
    secondsLbl.innerText = zeroPad(0, 2);
    wrapList = [];
    wrapListDom.innerHTML = "";
    startTime = 0;
    lastWrapStart = null;
    endBtn.disabled = true;
    wrapBtn.disabled = true;
  };

  const startTimer = () => {
    if (timer || startTime !== 0 || isBlockedTime()) return;
    startTime = new Date().getTime();
    lastStartDate = new Date();
    lastWrapStart = startTime;
    timer = setInterval(countUp, 100);
    startBtn.disabled = true;
    wrapBtn.disabled = false;
  };

  const resetTimerOnly = () => {
    clearInterval(timer);
    timer = null;
    setupTimer();
    startBtn.disabled = false;
  };

  const resetTimerAndDownload = () => {
    if (wrapList.length > 0) downloadMemo();
    resetTimerOnly();
  };

  const addWrap = () => {
    const now = new Date();
    const wrapEnd = now.getTime();
    const wrapStart = lastWrapStart || startTime;

    let effectiveDuration = 0;
    let current = wrapStart;
    while (current < wrapEnd) {
      const d = new Date(current);
      const hhmm = `${zeroPad(d.getHours(),2)}:${zeroPad(d.getMinutes(),2)}`;
      const blocked = blockedTimeRanges.some(([start, end]) => {
        if (start > end) return hhmm >= start || hhmm < end;
        return hhmm >= start && hhmm < end;
      });
      if (!blocked) effectiveDuration++;
      current += 1000;
    }

    const startStr = `${zeroPad(new Date(wrapStart).getHours(),2)}:${zeroPad(new Date(wrapStart).getMinutes(),2)}`;
    const endStr = `${zeroPad(now.getHours(),2)}:${zeroPad(now.getMinutes(),2)}`;
    const wrapStr = `${zeroPad(Math.floor(effectiveDuration / 60),2)}分${zeroPad(effectiveDuration % 60,2)}秒`;
    const text = `${wrapList.length+1}回目 ${startStr}～${endStr}　${wrapStr}`;

    const li = document.createElement("li");
    li.className = "wrap_item";
    li.textContent = text;
    if (effectiveDuration >= 1800) li.classList.add("over30");
    wrapListDom.appendChild(li);
    wrapList.push(text);
    endBtn.disabled = false;
    lastWrapStart = wrapEnd;
  };

  const downloadMemo = () => {
    const now = new Date();
    const dateStr = `${zeroPad(now.getFullYear(),4)}${zeroPad(now.getMonth()+1,2)}${zeroPad(now.getDate(),2)}_${zeroPad(now.getHours(),2)}${zeroPad(now.getMinutes(),2)}${zeroPad(now.getSeconds(),2)}`;
    const titleSafe = (customTitle || "記録").replace(/[^a-zA-Z0-9一-龯_]/g, "_");
    const fileName = `${titleSafe}_ラップタイム_${dateStr}.txt`;
    const header = `【${customTitle || "ラップタイム"} 記録】\n\n`;
    const body = wrapList.join("\n");
    const blob = new Blob([header + body], { type: "text/plain" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = fileName;
    a.click();
    URL.revokeObjectURL(url);
  };

  window.addEventListener("load", () => {
    setupTimer();
    startBtn.addEventListener("click", startTimer);
    resetBtn.addEventListener("click", resetTimerOnly);
    endBtn.addEventListener("click", resetTimerAndDownload);
    wrapBtn.addEventListener("click", addWrap);
  });

  secondsLbl.addEventListener("click", () => {
    if (!isManuallyBlocked) {
      isManuallyBlocked = true;
      pauseStartTime = new Date().getTime();
      if (timer) {
        clearInterval(timer);
        timer = null;
      }
    } else {
      isManuallyBlocked = false;
      pausedDuration += new Date().getTime() - pauseStartTime;
      if (!timer && startTime !== 0) {
        timer = setInterval(countUp, 100);
      }
    }
  });
</script>
